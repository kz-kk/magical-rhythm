<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>楽曲解析リズムゲーム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(to bottom right, #581c87, #1e3a8a, #312e81);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
            border-radius: 1rem;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
        }

        /* モバイル最適化 */
        @media (max-width: 480px) {
            body {
                padding: 0.25rem;
            }
            
            .game-container {
                padding: 0.75rem;
                max-width: 100%;
            }
            
            .title {
                font-size: 1.125rem;
            }
            
            .file-info {
                font-size: 0.625rem;
            }
            
            .stats {
                font-size: 0.625rem;
            }
            
            .game-area {
                height: 300px;
            }
            
            .tap-areas {
                height: 50px;
            }
            
            .tap-area {
                font-size: 0.625rem;
            }
            
            .note {
                height: 35px;
            }
            
            .judgment-text {
                font-size: 1rem;
            }
            
            .button {
                font-size: 0.625rem;
                padding: 0.5rem 0.75rem;
            }
            
            .difficulty-btn {
                font-size: 0.625rem;
                padding: 0.5rem 0.5rem;
            }
            
            .start-btn {
                font-size: 0.625rem;
                padding: 0.5rem 0.5rem;
                margin-left:10px;
            }
            
            
            .instructions {
                font-size: 0.5rem;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .title {
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
        }

        .file-info {
            font-size: 0.75rem;
            color: #d1d5db;
            margin-bottom: 0.5rem;
            word-break: break-all;
        }

        .simple-pattern {
            color: #facc15;
            margin-left: 0.5rem;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #d1d5db;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .upload-area {
            display: block;
            width: 100%;
            padding: 1rem;
            border: 2px dashed #9ca3af;
            border-radius: 0.5rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s;
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: #a855f7;
        }

        .upload-icon {
            display: inline-block;
            margin-bottom: 0.5rem;
            color: #9ca3af;
        }

        .upload-text {
            color: #d1d5db;
            display: block;
        }

        .upload-subtext {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .hidden {
            display: none;
        }

        .analysis-status {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .analysis-text {
            color: #facc15;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .progress-bar {
            width: 100%;
            background: #374151;
            border-radius: 9999px;
            height: 0.5rem;
            overflow: hidden;
        }

        .progress-fill {
            background: #facc15;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s;
        }

        .progress-hint {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }

        .success-status {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .success-text {
            color: #10b981;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
        }

        .volume-slider {
            flex: 1;
        }

        .volume-text {
            font-size: 0.625rem;
            color: #d1d5db;
            min-width: 32px;
        }

        .error-status {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .error-text {
            color: #ef4444;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .simple-pattern-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            background: #3b82f6;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            margin: 0 auto;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .simple-pattern-button:hover {
            background: #2563eb;
        }

        .simple-hint {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }

        .game-area {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 0.75rem;
            overflow: hidden;
            margin-bottom: 1rem;
            height: 350px;
        }

        .lanes {
            position: absolute;
            inset: 0;
            display: flex;
        }

        .lane {
            flex: 1;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .lane:last-child {
            border-right: none;
        }

        .judgment-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 2px solid #facc15;
            background: rgba(250, 204, 21, 0.2);
            height: 4px;
        }

        .note {
            position: absolute;
            width: 25%;
            height: 40px;
            background: linear-gradient(to bottom, #ec4899, #a855f7);
            border-radius: 0.25rem;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 8px -2px rgba(0, 0, 0, 0.1);
            transform: translateX(-50%);
        }

        .note.half {
            height: 20px;
            background: linear-gradient(to bottom, #f59e0b, #d97706);
        }

        .note.hit {
            opacity: 0.5;
        }

        .judgment-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.25rem;
            font-weight: bold;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .judgment-perfect { color: #facc15; }
        .judgment-good { color: #10b981; }
        .judgment-miss { color: #ef4444; }

        .tap-areas {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            height: 60px;
        }

        .tap-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background 0.3s;
            position: relative;
        }

        .tap-key {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }


        .tap-area:last-child {
            border-right: none;
        }

        .tap-area:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tap-area:active {
            background: rgba(255, 255, 255, 0.3);
        }


        .controls {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .button-green {
            background: #10b981;
        }

        .button-green:hover {
            background: #059669;
        }

        .button-yellow {
            background: #eab308;
        }

        .button-yellow:hover {
            background: #ca8a04;
        }

        .button-red {
            background: #ef4444;
        }

        .button-red:hover {
            background: #dc2626;
        }

        .button-blue {
            background: #3b82f6;
        }

        .button-blue:hover {
            background: #2563eb;
        }

        .new-file-link {
            text-align: center;
            margin-bottom: 1rem;
        }

        .link {
            font-size: 0.875rem;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.3s;
        }

        .link:hover {
            color: white;
        }

        .instructions {
            font-size: 0.625rem;
            color: #9ca3af;
            text-align: center;
            line-height: 1.4;
        }

        .instructions p {
            margin-bottom: 0.25rem;
        }

        /* モーダル */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }


        .modal-content {
            background: linear-gradient(to bottom, rgba(88, 28, 135, 0.9), rgba(30, 58, 138, 0.9));
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .modal-text {
            color: #e5e7eb;
            text-align: center;
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .modal-text-en {
            color: #d1d5db;
            font-size: 0.875rem;
            margin-bottom: 2rem;
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .modal-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.875rem;
        }

        .modal-button-primary {
            background: #a855f7;
            color: white;
        }

        .modal-button-primary:hover {
            background: #9333ea;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .modal-button-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-button-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* スプラッシュ画面 */
        #splashScreen {
            z-index: 1100;
            transition: opacity 0.8s ease-out;
        }

        #splashScreen.fade-out {
            opacity: 0;
        }

        .splash-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
        }

        .splash-image {
            width: 100%;
            height: auto;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .splash-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .splash-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 1rem;
            font-weight: 500;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        .splash-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.8);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* SVGアイコン */
        .icon {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .icon-small {
            width: 14px;
            height: 14px;
        }

        .icon-medium {
            width: 16px;
            height: 16px;
        }

        .icon-large {
            width: 28px;
            height: 28px;
        }

        .difficulty-text {
            text-align: center;
            color: #d1d5db;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
        }

        .difficulty-buttons {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .difficulty-and-reset-controls {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .difficulty-group {
            display: flex;
            gap: 0.25rem;
            flex: 1;
        }

        .reset-group {
            margin-left: 10px;
        }

        .difficulty-btn {
            flex: 1;
            opacity: 0.6;
            transition: opacity 0.3s;
            padding: 0.5rem 0.5rem;
            font-size: 0.625rem;
        }

        .difficulty-btn.active {
            opacity: 1;
        }

        .start-btn {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: bold;
            margin-top: 30px;
        }

    </style>
</head>
<body>
    <!-- スプラッシュ画面 -->
    <div id="splashScreen" class="modal-overlay">
        <div class="splash-content">
            <img id="splashImage" src="./assets/images/screen.jpg" alt="Magical Rhythm" class="splash-image">
            <div class="splash-overlay">
                <button id="splashButton" class="splash-button">タップして開始</button>
            </div>
        </div>
    </div>

    <!-- ウェルカムモーダル -->
    <div id="welcomeModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="modal-title">🎵 MAGICAL RHYTHM へようこそ！</h2>
            <p class="modal-text">
                「Select Another Song」<br>ボタンをクリックして、<br>
                好きな曲をアップロードしてプレイ！
            </p>
            <p class="modal-text modal-text-en">
                Click "Select Another Song"<br>button to upload<br>
                and play with your favorite music!
            </p>
            <div class="modal-buttons">
                <button id="modalSelectSong" class="modal-button modal-button-primary">
                    曲を選択 Select Song
                </button>
                <button id="modalPlayDefault" class="modal-button modal-button-secondary">
                    デモ曲でプレイ  Play Demo
                </button>
            </div>
        </div>
    </div>

    <div class="game-container">
        <!-- ヘッダー -->
        <div class="header">
            <div class="title-container">
                <svg class="icon" viewBox="0 0 24 24" style="stroke: #a855f7;">
                    <path d="M9 18V5l12-2v13M9 9l12-2M3 9h1m0 0a2 2 0 0 0 2 2 2 2 0 0 0 2-2m-4 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2m-1 7h1m0 0a2 2 0 0 0 2 2 2 2 0 0 0 2-2m-4 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2"></path>
                </svg>
                <h1 class="title">MAGICAL RHYTHM</h1>
            </div>
            <div id="fileInfo" class="file-info hidden"></div>
            <div class="stats">
                <span>Score: <span id="score">0</span></span>
                <span>Combo: <span id="combo">0</span></span>
                <span id="duration" class="hidden">Duration: <span id="durationValue">0</span>s</span>
            </div>
        </div>

        <!-- 音楽ファイルアップロード -->
        <label id="uploadArea" class="upload-area">
            <svg class="icon icon-large upload-icon" viewBox="0 0 24 24">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"></path>
            </svg>
            <span class="upload-text">UPLOAD</span>
            <div class="upload-subtext">MP3</div>
            <input type="file" accept="audio/*,.mp3,.wav,.ogg,.m4a,.flac,.aac" id="fileInput" class="hidden">
        </label>

        <!-- 解析状態 -->
        <div id="analysisStatus" class="analysis-status hidden">
            <div class="analysis-text">Analyzing music... <span id="progressPercent">0</span>%</div>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-hint">Large files may take longer to process</div>
        </div>

        <!-- 解析完了 -->
        <div id="successStatus" class="success-status hidden">
            <div class="success-text">Analysis complete! <span id="beatCount">0</span> beats detected</div>
            <div class="volume-control">
                <svg class="icon icon-small" viewBox="0 0 24 24" style="stroke: #9ca3af;">
                    <path d="M11 5L6 9H2v6h4l5 4V5zM19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
                <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.1" value="0.5">
                <span class="volume-text"><span id="volumeValue">50</span>%</span>
            </div>
        </div>

        <!-- 難易度選択とリセット -->
        <div id="difficultySelection" class="controls hidden">
            <div class="difficulty-and-reset-controls">
                <div class="difficulty-group">
                    <button id="easyBtn" class="button button-green difficulty-btn active">
                        <svg class="icon icon-small" viewBox="0 0 24 24">
                            <path d="M20 12c0 4.4-3.6 8-8 8s-8-3.6-8-8 3.6-8 8-8 8 3.6 8 8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        Easy
                    </button>
                    <button id="normalBtn" class="button button-yellow difficulty-btn">
                        <svg class="icon icon-small" viewBox="0 0 24 24">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                        </svg>
                        Normal
                    </button>
                    <button id="hardBtn" class="button button-red difficulty-btn">
                        <svg class="icon icon-small" viewBox="0 0 24 24">
                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                        </svg>
                        Hard
                    </button>
                </div>
                <div class="reset-group">
                    <button id="resetBtn" class="button button-red hidden">
                        <svg class="icon icon-medium" viewBox="0 0 24 24">
                            <polyline points="1 4 1 10 7 10"></polyline>
                            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                        </svg>
                        RESET                
                    </button>
                </div>
            </div>
            
        </div>

        <!-- エラー状態 -->
        <div id="errorStatus" class="error-status hidden">
            <div class="error-text">解析に失敗しました</div>
            <button id="simplePatternBtn" class="simple-pattern-button">
                <svg class="icon icon-small" viewBox="0 0 24 24">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                </svg>
                シンプルパターンを使用
            </button>
            <div class="simple-hint">120 BPMの等間隔パターンを生成</div>
        </div>

        <!-- ゲームエリア -->
        <div id="gameArea" class="game-area">
            <!-- レーン -->
            <div class="lanes">
                <div class="lane"></div>
                <div class="lane"></div>
                <div class="lane"></div>
                <div class="lane"></div>
            </div>

            <!-- 判定ライン -->
            <div class="judgment-line" style="top: 290px;"></div>

            <!-- ノート（動的に追加） -->
            <div id="notesContainer"></div>

            <!-- 判定テキスト -->
            <div id="judgmentText" class="judgment-text hidden"></div>

            <!-- タップエリア -->
            <div class="tap-areas">
                <button class="tap-area" data-lane="0">
                    <div class="tap-key">1</div>
                </button>
                <button class="tap-area" data-lane="1">
                    <div class="tap-key">2</div>
                </button>
                <button class="tap-area" data-lane="2">
                    <div class="tap-key">3</div>
                </button>
                <button class="tap-area" data-lane="3">
                    <div class="tap-key">4</div>
                </button>
            </div>
        </div>

        <!-- コントロール -->
        <div id="controls" class="controls">
            <button id="gameStartBtn" class="button button-green start-btn hidden">
                <svg class="icon icon-medium" viewBox="0 0 24 24">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
                START
            </button>
        </div>

        <!-- 新しいファイル選択 -->
        <div id="newFileArea" class="controls hidden">
            <label class="button button-blue">
                <svg class="icon icon-medium" viewBox="0 0 24 24">
                    <path d="M9 18V5l12-2v13M9 9l12-2M3 9h1m0 0a2 2 0 0 0 2 2 2 2 0 0 0 2-2m-4 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2m-1 7h1m0 0a2 2 0 0 0 2 2 2 2 0 0 0 2-2m-4 0a2 2 0 0 1 2-2 2 2 0 0 1 2 2"></path>
                </svg>
                Select Another Song
                <input type="file" accept="audio/*,.mp3,.wav,.ogg,.m4a,.flac,.aac" id="newFileInput" class="hidden">
            </label>
        </div>

        <!-- 操作説明 -->
        <div class="instructions">
            <!-- <p>音楽ファイルをアップロードして、楽曲のビートに合わせてプレイ！</p>
            <p>解析に失敗した場合は「シンプルパターン」を使用できます</p> -->
            <p>キーボード操作：1, 2, 3, 4 キーでもタップできます</p>
        </div>
    </div>

    <script>
        // ゲーム状態管理
        const gameState = {
            state: 'ready', // 'ready', 'playing', 'paused', 'finished'
            score: 0,
            combo: 0,
            notes: [],
            gameTime: 0,
            audioFile: null,
            isAnalyzing: false,
            analysisComplete: false,
            beatTimes: [],
            audioBuffer: null,
            volume: 0.5,
            analysisProgress: 0,
            useSimplePattern: false,
            difficulty: 'easy', // 'easy', 'normal', or 'hard'
            pauseTime: 0,
            pausedAt: 0
        };

        // ゲーム設定
        const NOTE_FALL_TIME = 2.0; // ノートが落ちてくる時間（秒）
        const JUDGMENT_LINE_Y = 290; // ゲームエリア縮小に合わせて調整
        const PERFECT_THRESHOLD = 30; // PERFECTの判定範囲（ピクセル）
        const GOOD_THRESHOLD = 60; // GOODの判定範囲（ピクセル）

        // Audio関連
        let audioContext = null;
        let audioSource = null;
        let gainNode = null;
        let gameStartTime = 0;
        let nextNoteIndex = 0;
        let animationFrame = null;
        let lastNoteLanes = []; // 直前のノートのレーンを記録

        // DOM要素の取得
        const elements = {
            fileInput: document.getElementById('fileInput'),
            newFileInput: document.getElementById('newFileInput'),
            uploadArea: document.getElementById('uploadArea'),
            analysisStatus: document.getElementById('analysisStatus'),
            successStatus: document.getElementById('successStatus'),
            errorStatus: document.getElementById('errorStatus'),
            fileInfo: document.getElementById('fileInfo'),
            newFileArea: document.getElementById('newFileArea'),
            progressPercent: document.getElementById('progressPercent'),
            progressFill: document.getElementById('progressFill'),
            beatCount: document.getElementById('beatCount'),
            volumeSlider: document.getElementById('volumeSlider'),
            volumeValue: document.getElementById('volumeValue'),
            score: document.getElementById('score'),
            combo: document.getElementById('combo'),
            duration: document.getElementById('duration'),
            durationValue: document.getElementById('durationValue'),
            notesContainer: document.getElementById('notesContainer'),
            judgmentText: document.getElementById('judgmentText'),
            gameStartBtn: document.getElementById('gameStartBtn'),
            resetBtn: document.getElementById('resetBtn'),
            difficultySelection: document.getElementById('difficultySelection'),
            easyBtn: document.getElementById('easyBtn'),
            normalBtn: document.getElementById('normalBtn'),
            hardBtn: document.getElementById('hardBtn'),
            simplePatternBtn: document.getElementById('simplePatternBtn'),
            welcomeModal: document.getElementById('welcomeModal'),
            modalSelectSong: document.getElementById('modalSelectSong'),
            modalPlayDefault: document.getElementById('modalPlayDefault')
        };

        // ファイルアップロード処理
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            await processAudioFile(file);
        }

        // 進捗更新
        function updateProgress(percent) {
            gameState.analysisProgress = percent;
            elements.progressPercent.textContent = Math.floor(percent);
            elements.progressFill.style.width = percent + '%';
        }

        // 軽量化された音楽解析
        async function analyzeMusicLight(audioBuffer) {
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const duration = audioBuffer.duration;
            const beats = [];

            // データを間引いて処理速度を向上
            const downsampleRate = 4;
            const downsampledData = [];
            for (let i = 0; i < channelData.length; i += downsampleRate) {
                downsampledData.push(channelData[i]);
            }

            const effectiveSampleRate = sampleRate / downsampleRate;
            const windowSize = Math.floor(effectiveSampleRate * 0.1);
            const hopSize = Math.floor(effectiveSampleRate * 0.2);

            let energyHistory = [];
            const energyHistorySize = 10;

            for (let i = 0; i < downsampledData.length - windowSize; i += hopSize) {
                // 進捗更新
                const progress = 60 + (i / downsampledData.length) * 40;
                updateProgress(Math.floor(progress));

                // エネルギー計算（RMS）
                let energy = 0;
                for (let j = i; j < i + windowSize; j++) {
                    energy += downsampledData[j] * downsampledData[j];
                }
                energy = Math.sqrt(energy / windowSize);

                energyHistory.push(energy);
                if (energyHistory.length > energyHistorySize) {
                    energyHistory.shift();
                }

                // シンプルなビート検出
                if (energyHistory.length === energyHistorySize) {
                    const avgEnergy = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
                    const maxEnergy = Math.max(...energyHistory);
                    const threshold = avgEnergy * 1.3; // 感度を上げる

                    const currentTime = (i * downsampleRate) / sampleRate;
                    
                    if (energy > threshold && energy > maxEnergy * 0.7) { // 感度を上げる
                        // 近接するビートを除外
                        const lastBeat = beats[beats.length - 1];
                        if (!lastBeat || currentTime - lastBeat > 0.25) { // より密なビートを許可
                            beats.push(currentTime);
                        }
                    }
                }

                // 処理を他のタスクに譲る
                if (i % 1000 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // ビートが少ない場合は等間隔で補完
            if (beats.length < 10) {
                const bpm = 120;
                const beatInterval = 60 / bpm;
                const supplementaryBeats = [];
                
                for (let time = 0; time < duration; time += beatInterval) {
                    supplementaryBeats.push(time);
                }
                
                return supplementaryBeats;
            }

            return beats.sort((a, b) => a - b);
        }

        // シンプルパターン生成
        function generateSimplePattern() {
            if (!gameState.audioBuffer) return;

            const duration = gameState.audioBuffer.duration;
            const bpm = 120;
            const beatInterval = 60 / bpm;
            const beats = [];

            for (let time = 0.5; time < duration - 0.5; time += beatInterval) {
                beats.push(time);
            }

            gameState.beatTimes = beats;
            gameState.analysisComplete = true;
            gameState.useSimplePattern = true;

            // UI更新
            elements.errorStatus.classList.add('hidden');
            elements.successStatus.classList.remove('hidden');
            elements.beatCount.textContent = beats.length;
            elements.duration.classList.remove('hidden');
            elements.durationValue.textContent = Math.floor(gameState.audioBuffer.duration);
            showDifficultySelection();

            // ファイル情報更新
            if (gameState.useSimplePattern) {
                elements.fileInfo.innerHTML = gameState.audioFile.name + '<span class="simple-pattern">(シンプルパターン)</span>';
            }
        }

        // 音楽再生
        function playMusic(offset = 0) {
            if (!gameState.audioBuffer || !audioContext) return;

            if (audioSource) {
                audioSource.stop();
            }

            audioSource = audioContext.createBufferSource();
            audioSource.buffer = gameState.audioBuffer;

            if (!gainNode) {
                gainNode = audioContext.createGain();
            }
            gainNode.gain.value = gameState.volume;

            audioSource.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // 指定されたオフセットから再生開始
            const startTime = audioContext.currentTime;
            audioSource.start(startTime, offset);
            
            // ゲーム開始時刻を音楽開始と同期（オフセットを考慮）
            if (offset === 0) {
                gameStartTime = Date.now();
            }
            
            return startTime;
        }

        // 音声ファイルのキャッシュ
        let audioBufferCache = {};

        async function loadAudioFile(url) {
            if (audioBufferCache[url]) {
                return audioBufferCache[url];
            }
            
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioBufferCache[url] = audioBuffer;
                return audioBuffer;
            } catch (error) {
                console.warn('音声ファイルの読み込みに失敗:', error, 'URL:', url);
                return null;
            }
        }

        async function playAudioFile(url, volume = 0.5) {
            if (!audioContext) return;
            
            // ローカル環境かどうかを判定して適切なURLを使用
            const finalUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:'
                ? url
                : url.replace('./assets/sounds/', 'https://kz-kk.github.io/magical-rhythm/assets/sounds/');
            
            const buffer = await loadAudioFile(finalUrl);
            if (!buffer) return;
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = buffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            
            source.start();
        }

        // タップ音生成
        function playTapSound(type = 'hit') {
            if (!audioContext) return;

            if (type === 'perfect' || type === 'good') {
                // 成功音として音声ファイルのみを再生
                playAudioFile('./assets/sounds/attach.mp3', 3.0);
            } else {
                // 通常のタップ音やミス音
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                if (type === 'miss') {
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.type = 'square';
                } else {
                    // 通常のタップ音
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                }

                // 音量エンベロープ
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            }
        }


        // 難易度選択表示
        function showDifficultySelection() {
            elements.difficultySelection.classList.remove('hidden');
            showReadyControls();
        }

        // 難易度選択
        function selectDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            elements.easyBtn.classList.toggle('active', difficulty === 'easy');
            elements.normalBtn.classList.toggle('active', difficulty === 'normal');
            elements.hardBtn.classList.toggle('active', difficulty === 'hard');
        }

        // ゲーム開始・一時停止・再開
        function startGame() {
            if (!gameState.analysisComplete || !gameState.beatTimes.length) return;

            if (gameState.state === 'playing') {
                // 再生中なら一時停止
                pauseGame();
            } else if (gameState.state === 'paused') {
                // 一時停止中なら再開
                resumeGame();
            } else {
                // 初回開始
                gameState.state = 'playing';
                gameState.score = 0;
                gameState.combo = 0;
                gameState.notes = [];
                gameState.gameTime = 0;
                nextNoteIndex = 0;
                lastNoteLanes = []; // レーン履歴をリセット

                updateScore();
                updateCombo();
                showGameControls();

                // 音楽を再生（playMusicが開始時刻を設定）
                playMusic();
                gameLoop();
            }
        }

        // ゲーム一時停止
        function pauseGame() {
            gameState.state = 'paused';
            gameState.pauseTime = Date.now();
            
            // 現在の再生位置を記録
            gameState.pausedAt = (Date.now() - gameStartTime) / 1000;
            
            // 音楽停止
            if (audioSource) {
                audioSource.stop();
            }
            
            // アニメーションフレーム停止
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            // ボタン表示更新
            updateStartButton();
        }

        // ゲーム再開
        function resumeGame() {
            gameState.state = 'playing';
            
            // 音楽を一時停止した位置から再開
            const resumeOffset = gameState.pausedAt || 0;
            gameStartTime = Date.now() - (resumeOffset * 1000);
            
            // 音楽再開（オフセット指定）
            playMusic(resumeOffset);
            gameLoop();
            
            // ボタン表示更新
            updateStartButton();
        }

        // STARTボタンの表示を更新
        function updateStartButton() {
            const startBtn = elements.gameStartBtn;
            if (gameState.state === 'playing') {
                startBtn.innerHTML = `
                    <svg class="icon icon-medium" viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    PAUSE
                `;
            } else {
                startBtn.innerHTML = `
                    <svg class="icon icon-medium" viewBox="0 0 24 24">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    START
                `;
            }
        }


        // ゲームリセット
        function resetGame() {
            gameState.state = 'ready';
            gameState.score = 0;
            gameState.combo = 0;
            gameState.notes = [];
            gameState.gameTime = 0;
            
            if (audioSource) {
                audioSource.stop();
            }
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }

            clearNotes();
            updateScore();
            updateCombo();
            hideJudgment();
            
            
            // 難易度選択を再表示
            elements.difficultySelection.classList.remove('hidden');
            showReadyControls();
        }


        // タップ処理
        function handleTap(lane) {
            if (gameState.state !== 'playing') return;

            let hitNote = null;
            let minDistance = Infinity;

            gameState.notes.forEach(note => {
                if (note.lane === lane && !note.hit) {
                    const distance = Math.abs(note.y - JUDGMENT_LINE_Y);
                    if (distance < minDistance && distance < GOOD_THRESHOLD) {
                        minDistance = distance;
                        hitNote = note;
                    }
                }
            });

            if (hitNote) {
                hitNote.hit = true;
                let points = 0;
                let judgment = '';
                let soundType = 'hit';

                if (minDistance < PERFECT_THRESHOLD) {
                    points = 100;
                    judgment = 'PERFECT!';
                    soundType = 'perfect';
                    gameState.combo++;
                } else if (minDistance < GOOD_THRESHOLD) {
                    points = 50;
                    judgment = 'GOOD!';
                    soundType = 'good';
                    gameState.combo++;
                }

                playTapSound(soundType);
                gameState.score += points;
                updateScore();
                updateCombo();
                showJudgment(judgment);

                // ノートを削除
                const noteElement = document.getElementById(`note-${hitNote.id}`);
                if (noteElement) {
                    noteElement.remove();
                }
                gameState.notes = gameState.notes.filter(note => note.id !== hitNote.id);
            } else {
                gameState.combo = 0;
                updateCombo();
                showJudgment('MISS!');
                playTapSound('miss');
            }
        }

        // 判定表示
        function showJudgment(judgment) {
            elements.judgmentText.textContent = judgment;
            elements.judgmentText.className = 'judgment-text';
            
            if (judgment === 'PERFECT!') {
                elements.judgmentText.classList.add('judgment-perfect');
            } else if (judgment === 'GOOD!') {
                elements.judgmentText.classList.add('judgment-good');
            } else {
                elements.judgmentText.classList.add('judgment-miss');
            }
            
            elements.judgmentText.classList.remove('hidden');
            
            setTimeout(() => {
                elements.judgmentText.classList.add('hidden');
            }, 500);
        }

        function hideJudgment() {
            elements.judgmentText.classList.add('hidden');
        }

        // スコア・コンボ更新
        function updateScore() {
            elements.score.textContent = gameState.score;
        }

        function updateCombo() {
            elements.combo.textContent = gameState.combo;
        }

        // ノート管理
        function createNoteElement(note) {
            const noteElement = document.createElement('div');
            noteElement.id = `note-${note.id}`;
            noteElement.className = note.isHalf ? 'note half' : 'note';
            noteElement.style.left = `${(note.lane + 0.5) * 25}%`;
            noteElement.style.top = `${note.y}px`;
            return noteElement;
        }

        function clearNotes() {
            elements.notesContainer.innerHTML = '';
        }

        // ゲームループ
        function gameLoop() {
            const currentTime = (Date.now() - gameStartTime) / 1000;
            gameState.gameTime = currentTime * 1000;

            if (gameState.audioBuffer && currentTime >= gameState.audioBuffer.duration) {
                gameState.state = 'finished';
                showFinishControls();
                return;
            }

            // 新しいノートを生成
            while (nextNoteIndex < gameState.beatTimes.length) {
                const beatTime = gameState.beatTimes[nextNoteIndex];
                const appearTime = beatTime - NOTE_FALL_TIME; // ノートが落ちてくる時間
                
                if (appearTime <= currentTime) {
                    // 難易度による設定
                    let noteCount = 1;
                    let generateExtra = false;
                    
                    if (gameState.difficulty === 'easy') {
                        // Easy: 基本的に1個のノート、たまに2個
                        if (Math.random() < 0.2) { // 20%の確率で2個
                            noteCount = 2;
                        }
                        // 追加ノート生成なし
                        
                    } else if (gameState.difficulty === 'normal') {
                        // Normal: 1-2個のノート、適度な追加ノート
                        noteCount = Math.floor(Math.random() * 2) + 1; // 1-2個
                        
                        // 30%の確率で追加ノート
                        if (Math.random() < 0.3 && nextNoteIndex < gameState.beatTimes.length - 1) {
                            generateExtra = true;
                        }
                        
                    } else if (gameState.difficulty === 'hard') {
                        // Hard: 1-3個のノート、多めの追加ノート
                        const rand = Math.random();
                        if (rand < 0.4) {
                            noteCount = 1; // 40%
                        } else if (rand < 0.8) {
                            noteCount = 2; // 40%
                        } else {
                            noteCount = 3; // 20%
                        }
                        
                        // 50%の確率で追加ノート
                        if (Math.random() < 0.5 && nextNoteIndex < gameState.beatTimes.length - 1) {
                            generateExtra = true;
                        }
                    }
                    
                    
                    const usedLanes = new Set();
                    const currentNoteLanes = [];
                    
                    for (let i = 0; i < noteCount; i++) {
                        let lane;
                        let attempts = 0;
                        do {
                            lane = Math.floor(Math.random() * 4);
                            attempts++;
                            // 無限ループを防ぐ
                            if (attempts > 20) break;
                        } while (usedLanes.has(lane) || 
                                (gameState.difficulty === 'hard' && lastNoteLanes.includes(lane)));
                        
                        usedLanes.add(lane);
                        currentNoteLanes.push(lane);
                        
                        const noteId = Date.now() + Math.random() + i;
                        
                        const note = {
                            id: noteId,
                            lane: lane,
                            y: -50,
                            targetTime: beatTime,
                            hit: false
                        };
                        
                        gameState.notes.push(note);
                        
                        // DOM要素作成
                        const noteElement = createNoteElement(note);
                        elements.notesContainer.appendChild(noteElement);
                    }
                    
                    // オレンジノート（連続タップ）生成
                    if (generateExtra && currentNoteLanes.length > 0) {
                        // 連続タップ用のオレンジノートを生成
                        let comboCount = gameState.difficulty === 'hard' ? 
                            Math.floor(Math.random() * 3) + 2 : // Hard: 2-4個
                            Math.floor(Math.random() * 2) + 2; // Normal: 2-3個
                            
                        // 最初のレーンを基準にする
                        const baseLane = currentNoteLanes[0];
                            
                        for (let i = 0; i < comboCount; i++) {
                            const comboDelay = 0.15 + (i * 0.15); // 0.15秒間隔で連続
                            const comboTime = beatTime + comboDelay;
                            
                            if (comboTime < gameState.audioBuffer.duration) {
                                // 隣接するレーンを選択（1→2、2→3など）
                                let comboLane = baseLane;
                                if (i > 0) {
                                    // 前のノートから隣接するレーンに移動
                                    const direction = Math.random() < 0.5 ? -1 : 1;
                                    comboLane = Math.max(0, Math.min(3, baseLane + (direction * (i % 2 === 0 ? 1 : -1))));
                                }
                                
                                const comboNoteId = Date.now() + Math.random() + 1000 + i;
                                const comboNote = {
                                    id: comboNoteId,
                                    lane: comboLane,
                                    y: -50,
                                    targetTime: comboTime,
                                    hit: false,
                                    isHalf: true // オレンジノートフラグ
                                };
                                
                                gameState.notes.push(comboNote);
                                
                                // DOM要素作成
                                const comboNoteElement = createNoteElement(comboNote);
                                elements.notesContainer.appendChild(comboNoteElement);
                            }
                        }
                    }
                    
                    // Hardモードでは直前のレーンを記録
                    if (gameState.difficulty === 'hard') {
                        lastNoteLanes = currentNoteLanes.slice(); // コピーして保存
                        // 最大5個までしか記録しない
                        if (lastNoteLanes.length > 5) {
                            lastNoteLanes = lastNoteLanes.slice(-5);
                        }
                    }
                    
                    nextNoteIndex++;
                } else {
                    break;
                }
            }

            // ノートの位置を更新
            gameState.notes.forEach(note => {
                if (!note.hit) {
                    // ノートが判定ラインに到達するまでの残り時間
                    const timeUntilTarget = note.targetTime - currentTime;
                    // 残り時間に基づいてY座標を計算（判定ラインが0、画面上部が負の値）
                    const progress = 1 - (timeUntilTarget / NOTE_FALL_TIME);
                    const newY = progress * (JUDGMENT_LINE_Y + 50) - 50;
                    note.y = newY;
                    
                    const noteElement = document.getElementById(`note-${note.id}`);
                    if (noteElement) {
                        noteElement.style.top = `${newY}px`;
                        if (note.hit) {
                            noteElement.classList.add('hit');
                        }
                    }
                }
            });

            // 画面外のノートを削除
            gameState.notes = gameState.notes.filter(note => {
                if (!note.hit && note.y > JUDGMENT_LINE_Y + GOOD_THRESHOLD) {
                    gameState.combo = 0;
                    updateCombo();
                    
                    const noteElement = document.getElementById(`note-${note.id}`);
                    if (noteElement) {
                        noteElement.remove();
                    }
                    return false;
                }
                return true;
            });

            if (gameState.state === 'playing') {
                animationFrame = requestAnimationFrame(gameLoop);
            }
        }

        // コントロール表示管理
        function showGameControls() {
            elements.difficultySelection.classList.add('hidden');
            elements.gameStartBtn.classList.remove('hidden');
            updateStartButton();
        }

        function showFinishControls() {
            elements.gameStartBtn.classList.remove('hidden');
            updateStartButton();
        }

        function showReadyControls() {
            elements.gameStartBtn.classList.remove('hidden');
            updateStartButton();
        }

        // イベントリスナー設定
        elements.fileInput.addEventListener('change', handleFileUpload);
        elements.newFileInput.addEventListener('change', handleFileUpload);
        elements.simplePatternBtn.addEventListener('click', generateSimplePattern);
        elements.gameStartBtn.addEventListener('click', startGame);
        elements.resetBtn.addEventListener('click', resetGame);
        elements.easyBtn.addEventListener('click', () => selectDifficulty('easy'));
        elements.normalBtn.addEventListener('click', () => selectDifficulty('normal'));
        elements.hardBtn.addEventListener('click', () => selectDifficulty('hard'));

        // モーダルのイベントリスナー
        if (elements.modalSelectSong) {
            elements.modalSelectSong.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Select song button clicked'); // デバッグ用
                localStorage.setItem('magicalRhythmVisited', 'true');
                hideWelcomeModal();
                elements.newFileInput.click();
            });
        }

        if (elements.modalPlayDefault) {
            elements.modalPlayDefault.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Demo button clicked'); // デバッグ用
                localStorage.setItem('magicalRhythmVisited', 'true');
                hideWelcomeModal();
                loadDefaultMusic();
            });
        }

        // モーダル外クリックで閉じる
        if (elements.welcomeModal) {
            elements.welcomeModal.addEventListener('click', (e) => {
                if (e.target === elements.welcomeModal) {
                    console.log('Modal background clicked'); // デバッグ用
                    hideWelcomeModal();
                    // モーダル外クリック時はデモ曲をロードしない（ユーザーが選択するまで待つ）
                }
            });
        }

        // 音量調整
        elements.volumeSlider.addEventListener('input', (e) => {
            gameState.volume = parseFloat(e.target.value);
            elements.volumeValue.textContent = Math.floor(gameState.volume * 100);
            if (gainNode) {
                gainNode.gain.value = gameState.volume;
            }
        });

        // タップエリアのイベント
        document.querySelectorAll('.tap-area').forEach(area => {
            const lane = parseInt(area.dataset.lane);
            
            area.addEventListener('mousedown', (e) => {
                e.preventDefault();
                handleTap(lane);
            });
            
            area.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleTap(lane);
            });
        });

        // キーボード操作
        window.addEventListener('keydown', (event) => {
            if (gameState.state !== 'playing') return;
            
            const key = event.key;
            let lane = -1;
            
            switch(key) {
                case '1':
                    lane = 0;
                    break;
                case '2':
                    lane = 1;
                    break;
                case '3':
                    lane = 2;
                    break;
                case '4':
                    lane = 3;
                    break;
                default:
                    return;
            }
            
            if (lane >= 0) {
                event.preventDefault();
                handleTap(lane);
            }
        });

        // モーダル表示・非表示
        function showWelcomeModal() {
            elements.welcomeModal.classList.remove('hidden');
            elements.welcomeModal.style.display = 'flex'; // 強制的に表示
        }

        function hideWelcomeModal() {
            console.log('Hiding modal'); // デバッグ用
            console.log('Modal element:', elements.welcomeModal); // デバッグ用
            console.log('Classes before:', elements.welcomeModal.className); // デバッグ用
            elements.welcomeModal.classList.add('hidden');
            elements.welcomeModal.style.display = 'none'; // 強制的に非表示
            console.log('Classes after:', elements.welcomeModal.className); // デバッグ用
        }

        // デフォルト音楽ファイルを読み込む関数
        async function loadDefaultMusic() {
            try {
                // デフォルトファイルのパス
                const defaultMusicPath = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:'
                    ? './assets/sounds/hyper_dream_dash.mp3'
                    : 'https://kz-kk.github.io/magical-rhythm/assets/sounds/hyper_dream_dash.mp3';
                
                // ファイルをfetchで読み込み
                const response = await fetch(defaultMusicPath);
                if (!response.ok) {
                    console.log('デフォルト音楽ファイルが見つかりません - アップロードエリアを表示します');
                    // アップロードエリアを表示
                    elements.uploadArea.classList.remove('hidden');
                    return;
                }
                
                const blob = await response.blob();
                
                // Fileオブジェクトを作成
                const file = new File([blob], 'hyper_dream_dash.mp3', { type: 'audio/mp3' });
                
                // ファイルアップロード処理を実行
                await processAudioFile(file);
                
            } catch (error) {
                console.log('デフォルト音楽ファイルの読み込みに失敗:', error);
                // エラー時はアップロードエリアを表示
                elements.uploadArea.classList.remove('hidden');
            }
        }

        // 音楽ファイル処理を共通化
        async function processAudioFile(file) {
            gameState.audioFile = file;
            gameState.isAnalyzing = true;
            gameState.analysisComplete = false;
            gameState.analysisProgress = 0;
            gameState.useSimplePattern = false;

            // UI更新
            elements.uploadArea.classList.add('hidden');
            elements.analysisStatus.classList.remove('hidden');
            elements.fileInfo.textContent = file.name;
            elements.fileInfo.classList.remove('hidden');
            elements.newFileArea.classList.remove('hidden');

            try {
                // Audio Context初期化
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                updateProgress(20);

                // ファイル読み込み
                const arrayBuffer = await file.arrayBuffer();
                updateProgress(40);

                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                gameState.audioBuffer = audioBuffer;
                updateProgress(60);

                // 音楽解析
                const beats = await analyzeMusicLight(audioBuffer);
                
                // 静かな曲でもある程度のノートを確保
                const minBeatsPerSecond = 0.5; // 最低でも2秒に1回
                const minTotalBeats = Math.floor(audioBuffer.duration * minBeatsPerSecond);
                
                if (beats.length < minTotalBeats) {
                    // ビートが少なすぎる場合は補間
                    const additionalBeats = [];
                    const interval = audioBuffer.duration / minTotalBeats;
                    
                    for (let i = 0; i < minTotalBeats; i++) {
                        const time = i * interval;
                        // 既存のビートと重複しないようにチェック
                        const hasNearbyBeat = beats.some(beat => Math.abs(beat - time) < 0.3);
                        if (!hasNearbyBeat) {
                            additionalBeats.push(time);
                        }
                    }
                    
                    // 既存のビートと補間ビートを結合してソート
                    gameState.beatTimes = [...beats, ...additionalBeats].sort((a, b) => a - b);
                } else {
                    gameState.beatTimes = beats;
                }

                updateProgress(100);
                gameState.isAnalyzing = false;
                gameState.analysisComplete = true;

                // UI更新
                elements.analysisStatus.classList.add('hidden');
                elements.successStatus.classList.remove('hidden');
                elements.beatCount.textContent = gameState.beatTimes.length;
                elements.duration.classList.remove('hidden');
                elements.durationValue.textContent = Math.floor(audioBuffer.duration);
                showDifficultySelection();

            } catch (error) {
                console.error('音楽解析エラー:', error);
                gameState.isAnalyzing = false;
                gameState.analysisProgress = 0;
                
                // エラーUI表示
                elements.analysisStatus.classList.add('hidden');
                elements.errorStatus.classList.remove('hidden');
            }
        }

        // スプラッシュ画面の表示・非表示
        function showSplashScreen() {
            const splashScreen = document.getElementById('splashScreen');
            const splashImage = document.getElementById('splashImage');
            
            // 画像パスを環境に応じて設定
            const imagePath = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:'
                ? './assets/images/screen.jpg'
                : 'https://kz-kk.github.io/magical-rhythm/assets/images/screen.jpg';
            splashImage.src = imagePath;
            
            splashScreen.classList.remove('hidden');
        }

        function hideSplashScreen() {
            const splashScreen = document.getElementById('splashScreen');
            splashScreen.classList.add('fade-out');
            
            // フェードアウト完了後に完全に削除する
            setTimeout(() => {
                splashScreen.remove();
            }, 800); // transition時間と同じ
        }

        // ページ読み込み時の処理
        window.addEventListener('DOMContentLoaded', async () => {
            // 画像パスを環境に応じて設定
            const splashImage = document.getElementById('splashImage');
            const imagePath = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:'
                ? './assets/images/screen.jpg'
                : 'https://kz-kk.github.io/magical-rhythm/assets/images/screen.jpg';
            splashImage.src = imagePath;
            
            // スプラッシュボタンのクリックイベント
            const splashButton = document.getElementById('splashButton');
            splashButton.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                hideSplashScreen();
                
                // 効果音を事前にロード
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // attach.mp3を事前にロード
                const attachSoundPath = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:'
                    ? './assets/sounds/attach.mp3'
                    : 'https://kz-kk.github.io/magical-rhythm/assets/sounds/attach.mp3';
                await loadAudioFile(attachSoundPath);
                
                // 初回訪問かチェック（localStorage使用）
                const hasVisited = localStorage.getItem('magicalRhythmVisited');
                
                if (!hasVisited) {
                    // 初回訪問の場合はモーダルを表示
                    showWelcomeModal();
                } else {
                    // 既訪問の場合はデフォルト音楽を読み込み
                    loadDefaultMusic();
                }
            });
        });
    </script>
</body>
</html>