import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, Pause, RotateCcw, Music, Upload, Volume2, Zap } from 'lucide-react';

const MusicAnalyzerRhythmGame = () => {
  const [gameState, setGameState] = useState('ready');
  const [score, setScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [notes, setNotes] = useState([]);
  const [gameTime, setGameTime] = useState(0);
  const [judgmentText, setJudgmentText] = useState('');
  const [audioFile, setAudioFile] = useState(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisComplete, setAnalysisComplete] = useState(false);
  const [beatTimes, setBeatTimes] = useState([]);
  const [audioBuffer, setAudioBuffer] = useState(null);
  const [volume, setVolume] = useState(0.5);
  const [analysisProgress, setAnalysisProgress] = useState(0);
  const [useSimplePattern, setUseSimplePattern] = useState(false);
  
  const audioContextRef = useRef(null);
  const audioSourceRef = useRef(null);
  const gainNodeRef = useRef(null);
  const gameAreaRef = useRef(null);
  const animationRef = useRef(null);
  const gameStartTimeRef = useRef(0);
  const nextNoteIndexRef = useRef(0);

  const NOTE_SPEED = 300;
  const JUDGMENT_LINE_Y = 350;
  const PERFECT_THRESHOLD = 50;
  const GOOD_THRESHOLD = 100;

  // 音楽ファイルの読み込み
  const handleFileUpload = useCallback(async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setAudioFile(file);
    setIsAnalyzing(true);
    setAnalysisComplete(false);
    setAnalysisProgress(0);

    try {
      // Audio Contextの初期化
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }

      setAnalysisProgress(20);

      // ファイルを読み込んでArrayBufferに変換
      const arrayBuffer = await file.arrayBuffer();
      setAnalysisProgress(40);

      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
      setAudioBuffer(audioBuffer);
      setAnalysisProgress(60);

      // 軽量化された音楽解析を実行
      const beats = await analyzeMusicLight(audioBuffer);
      setBeatTimes(beats);
      
      setAnalysisProgress(100);
      setIsAnalyzing(false);
      setAnalysisComplete(true);
    } catch (error) {
      console.error('音楽解析エラー:', error);
      setIsAnalyzing(false);
      setAnalysisProgress(0);
      alert('音楽ファイルの解析に失敗しました。シンプルパターンを使用してください。');
    }
  }, []);

  // 軽量化された音楽解析
  const analyzeMusicLight = useCallback(async (audioBuffer) => {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    const duration = audioBuffer.duration;
    const beats = [];

    // データを間引いて処理速度を向上
    const downsampleRate = 4; // 4分の1に間引き
    const downsampledData = [];
    for (let i = 0; i < channelData.length; i += downsampleRate) {
      downsampledData.push(channelData[i]);
    }

    const effectiveSampleRate = sampleRate / downsampleRate;
    const windowSize = Math.floor(effectiveSampleRate * 0.1); // 100ms窓
    const hopSize = Math.floor(effectiveSampleRate * 0.2); // 200ms刻み（より粗く）

    let energyHistory = [];
    const energyHistorySize = 10; // 履歴を短縮

    for (let i = 0; i < downsampledData.length - windowSize; i += hopSize) {
      // 進捗更新
      const progress = 60 + (i / downsampledData.length) * 40;
      setAnalysisProgress(Math.floor(progress));

      // エネルギー計算（RMS）
      let energy = 0;
      for (let j = i; j < i + windowSize; j++) {
        energy += downsampledData[j] * downsampledData[j];
      }
      energy = Math.sqrt(energy / windowSize);

      energyHistory.push(energy);
      if (energyHistory.length > energyHistorySize) {
        energyHistory.shift();
      }

      // シンプルなビート検出
      if (energyHistory.length === energyHistorySize) {
        const avgEnergy = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
        const maxEnergy = Math.max(...energyHistory);
        const threshold = avgEnergy * 1.5;

        const currentTime = (i * downsampleRate) / sampleRate;
        
        if (energy > threshold && energy > maxEnergy * 0.8) {
          // 近接するビートを除外
          const lastBeat = beats[beats.length - 1];
          if (!lastBeat || currentTime - lastBeat > 0.4) {
            beats.push(currentTime);
          }
        }
      }

      // 処理を他のタスクに譲る
      if (i % 1000 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // ビートが少ない場合は等間隔で補完
    if (beats.length < 10) {
      const bpm = 120; // デフォルトBPM
      const beatInterval = 60 / bpm;
      const supplementaryBeats = [];
      
      for (let time = 0; time < duration; time += beatInterval) {
        supplementaryBeats.push(time);
      }
      
      return supplementaryBeats;
    }

    return beats.sort((a, b) => a - b);
  }, []);

  // シンプルパターンの生成
  const generateSimplePattern = useCallback(() => {
    if (!audioBuffer) return;

    const duration = audioBuffer.duration;
    const bpm = 120; // 120 BPM
    const beatInterval = 60 / bpm; // 0.5秒間隔
    const beats = [];

    for (let time = 0.5; time < duration - 0.5; time += beatInterval) {
      beats.push(time);
    }

    setBeatTimes(beats);
    setAnalysisComplete(true);
    setUseSimplePattern(true);
  }, [audioBuffer]);

  // 楽曲の再生
  const playMusic = useCallback(() => {
    if (!audioBuffer || !audioContextRef.current) return;

    if (audioSourceRef.current) {
      audioSourceRef.current.stop();
    }

    audioSourceRef.current = audioContextRef.current.createBufferSource();
    audioSourceRef.current.buffer = audioBuffer;

    if (!gainNodeRef.current) {
      gainNodeRef.current = audioContextRef.current.createGain();
    }
    gainNodeRef.current.gain.value = volume;

    audioSourceRef.current.connect(gainNodeRef.current);
    gainNodeRef.current.connect(audioContextRef.current.destination);

    audioSourceRef.current.start();
  }, [audioBuffer, volume]);

  // ゲーム開始
  const startGame = useCallback(() => {
    if (!analysisComplete || !beatTimes.length) return;

    setGameState('playing');
    setScore(0);
    setCombo(0);
    setNotes([]);
    setGameTime(0);
    setJudgmentText('');
    gameStartTimeRef.current = Date.now();
    nextNoteIndexRef.current = 0;

    playMusic();
  }, [analysisComplete, beatTimes, playMusic]);

  // ゲーム一時停止
  const togglePause = useCallback(() => {
    if (gameState === 'playing') {
      setGameState('paused');
      if (audioSourceRef.current) {
        audioSourceRef.current.stop();
      }
    } else if (gameState === 'paused') {
      setGameState('playing');
      playMusic();
    }
  }, [gameState, playMusic]);

  // ゲームリセット
  const resetGame = useCallback(() => {
    setGameState('ready');
    setScore(0);
    setCombo(0);
    setNotes([]);
    setGameTime(0);
    setJudgmentText('');
    
    if (audioSourceRef.current) {
      audioSourceRef.current.stop();
    }
    
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
  }, []);

  // タップ音の生成
  const playTapSound = useCallback((type = 'hit') => {
    if (!audioContextRef.current) return;

    const oscillator = audioContextRef.current.createOscillator();
    const gainNode = audioContextRef.current.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContextRef.current.destination);

    // タップ音のタイプによって音程を変える
    if (type === 'perfect') {
      oscillator.frequency.setValueAtTime(800, audioContextRef.current.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(400, audioContextRef.current.currentTime + 0.1);
    } else if (type === 'good') {
      oscillator.frequency.setValueAtTime(600, audioContextRef.current.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(300, audioContextRef.current.currentTime + 0.1);
    } else if (type === 'miss') {
      oscillator.frequency.setValueAtTime(150, audioContextRef.current.currentTime);
      oscillator.type = 'square';
    } else {
      // 通常のタップ音
      oscillator.frequency.setValueAtTime(400, audioContextRef.current.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(200, audioContextRef.current.currentTime + 0.1);
    }

    // 音量エンベロープ
    gainNode.gain.setValueAtTime(0.3, audioContextRef.current.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContextRef.current.currentTime + 0.15);

    oscillator.start();
    oscillator.stop(audioContextRef.current.currentTime + 0.15);
  }, []);

  // タップ処理
  const handleTap = useCallback((lane) => {
    if (gameState !== 'playing') return;

    let hitNote = null;
    let minDistance = Infinity;

    notes.forEach(note => {
      if (note.lane === lane && !note.hit) {
        const distance = Math.abs(note.y - JUDGMENT_LINE_Y);
        if (distance < minDistance && distance < GOOD_THRESHOLD) {
          minDistance = distance;
          hitNote = note;
        }
      }
    });

    if (hitNote) {
      hitNote.hit = true;
      let points = 0;
      let judgment = '';
      let soundType = 'hit';

      if (minDistance < PERFECT_THRESHOLD) {
        points = 100;
        judgment = 'PERFECT!';
        soundType = 'perfect';
        setCombo(prev => prev + 1);
      } else if (minDistance < GOOD_THRESHOLD) {
        points = 50;
        judgment = 'GOOD!';
        soundType = 'good';
        setCombo(prev => prev + 1);
      }

      // タップ音を再生
      playTapSound(soundType);

      setScore(prev => prev + points);
      setJudgmentText(judgment);
      setTimeout(() => setJudgmentText(''), 500);

      setNotes(prev => prev.filter(note => note.id !== hitNote.id));
    } else {
      setCombo(0);
      setJudgmentText('MISS!');
      setTimeout(() => setJudgmentText(''), 500);
      
      // ミス音を再生
      playTapSound('miss');
    }
  }, [gameState, notes, playTapSound]);

  // ゲームループ
  const gameLoop = useCallback(() => {
    const currentTime = (Date.now() - gameStartTimeRef.current) / 1000;
    setGameTime(currentTime * 1000);

    if (audioBuffer && currentTime >= audioBuffer.duration) {
      setGameState('finished');
      return;
    }

    // 新しいノートを生成
    while (nextNoteIndexRef.current < beatTimes.length) {
      const beatTime = beatTimes[nextNoteIndexRef.current];
      const appearTime = beatTime - 2;
      
      if (appearTime <= currentTime) {
        const lane = Math.floor(Math.random() * 4);
        
        setNotes(prev => [...prev, {
          id: Date.now() + Math.random(),
          lane: lane,
          y: -50,
          targetTime: beatTime,
          hit: false
        }]);
        
        nextNoteIndexRef.current++;
      } else {
        break;
      }
    }

    // ノートの位置を更新
    setNotes(prev => prev.map(note => {
      if (!note.hit) {
        const timeDiff = currentTime - note.targetTime + 2;
        const newY = (timeDiff / 2) * (JUDGMENT_LINE_Y + 50);
        return { ...note, y: newY };
      }
      return note;
    }));

    // 画面外のノートを削除
    setNotes(prev => prev.filter(note => {
      if (!note.hit && note.y > JUDGMENT_LINE_Y + GOOD_THRESHOLD) {
        setCombo(0);
        return false;
      }
      return true;
    }));

    if (gameState === 'playing') {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
  }, [gameState, beatTimes, audioBuffer]);

  // キーボード操作
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (gameState !== 'playing') return;
      
      const key = event.key;
      let lane = -1;
      
      switch(key) {
        case '1':
          lane = 0;
          break;
        case '2':
          lane = 1;
          break;
        case '3':
          lane = 2;
          break;
        case '4':
          lane = 3;
          break;
        default:
          return;
      }
      
      if (lane >= 0) {
        event.preventDefault();
        handleTap(lane);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, handleTap]);

  // ゲームループ開始
  useEffect(() => {
    if (gameState === 'playing') {
      animationRef.current = requestAnimationFrame(gameLoop);
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [gameState, gameLoop]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="bg-black/30 backdrop-blur-md rounded-2xl p-6 w-full max-w-md">
        {/* ヘッダー */}
        <div className="text-center mb-4">
          <div className="flex items-center justify-center gap-2 mb-2">
            <Music className="text-purple-400" size={24} />
            <h1 className="text-2xl font-bold text-white">楽曲解析リズムゲーム</h1>
          </div>
          {audioFile && (
            <div className="text-sm text-gray-300 mb-2">
              {audioFile.name}
              {useSimplePattern && <span className="text-yellow-400 ml-2">(シンプルパターン)</span>}
            </div>
          )}
          <div className="flex justify-between text-sm text-gray-300">
            <span>Score: {score}</span>
            <span>Combo: {combo}</span>
            {audioBuffer && (
              <span>Duration: {Math.floor(audioBuffer.duration)}s</span>
            )}
          </div>
        </div>

        {/* 音楽ファイルアップロード */}
        {!audioFile && (
          <div className="mb-4">
            <label className="block w-full p-6 border-2 border-dashed border-gray-400 rounded-lg text-center cursor-pointer hover:border-purple-400 transition-colors">
              <Upload className="mx-auto mb-2 text-gray-400" size={32} />
              <span className="text-gray-300">音楽ファイルをアップロード</span>
              <div className="text-xs text-gray-500 mt-1">MP3, WAV, OGG, M4A など</div>
              <input
                type="file"
                accept="audio/*,.mp3,.wav,.ogg,.m4a,.flac,.aac"
                onChange={handleFileUpload}
                className="hidden"
              />
            </label>
          </div>
        )}

        {/* 解析状態 */}
        {isAnalyzing && (
          <div className="text-center mb-4">
            <div className="text-yellow-400 mb-2">楽曲を解析中... {analysisProgress}%</div>
            <div className="w-full bg-gray-700 rounded-full h-2">
              <div 
                className="bg-yellow-400 h-2 rounded-full transition-all duration-300" 
                style={{ width: `${analysisProgress}%` }} 
              />
            </div>
            <div className="text-xs text-gray-400 mt-1">
              大きなファイルは時間がかかります
            </div>
          </div>
        )}

        {/* 解析完了 */}
        {analysisComplete && (
          <div className="text-center mb-4">
            <div className="text-green-400 mb-2">
              解析完了！ {beatTimes.length} 個のビートを検出
            </div>
            
            {/* 音量調整 */}
            <div className="flex items-center gap-2 mb-2">
              <Volume2 className="text-gray-400" size={16} />
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={volume}
                onChange={(e) => setVolume(parseFloat(e.target.value))}
                className="flex-1"
              />
              <span className="text-sm text-gray-300">{Math.floor(volume * 100)}%</span>
            </div>
          </div>
        )}

        {/* 解析が失敗した場合の代替オプション */}
        {audioBuffer && !analysisComplete && !isAnalyzing && (
          <div className="text-center mb-4">
            <div className="text-red-400 mb-2">解析に失敗しました</div>
            <button
              onClick={generateSimplePattern}
              className="flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors mx-auto"
            >
              <Zap size={16} />
              シンプルパターンを使用
            </button>
            <div className="text-xs text-gray-400 mt-1">
              120 BPMの等間隔パターンを生成
            </div>
          </div>
        )}

        {/* ゲームエリア */}
        <div 
          ref={gameAreaRef}
          className="relative bg-black/50 rounded-xl overflow-hidden mb-4"
          style={{ height: '400px' }}
        >
          {/* レーン */}
          <div className="absolute inset-0 flex">
            {[0, 1, 2, 3].map(lane => (
              <div
                key={lane}
                className="flex-1 border-r border-white/20 last:border-r-0"
              />
            ))}
          </div>

          {/* 判定ライン */}
          <div 
            className="absolute left-0 right-0 border-t-2 border-yellow-400 bg-yellow-400/20"
            style={{ top: `${JUDGMENT_LINE_Y}px`, height: '4px' }}
          />

          {/* ノート */}
          {notes.map(note => (
            <div
              key={note.id}
              className="absolute w-1/4 h-12 bg-gradient-to-b from-pink-400 to-purple-500 rounded-lg border-2 border-white/50 shadow-lg transform -translate-x-1/2"
              style={{
                left: `${(note.lane + 0.5) * 25}%`,
                top: `${note.y}px`,
                opacity: note.hit ? 0.5 : 1
              }}
            />
          ))}

          {/* 判定テキスト */}
          {judgmentText && (
            <div className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-2xl font-bold animate-pulse ${
              judgmentText === 'PERFECT!' ? 'text-yellow-400' :
              judgmentText === 'GOOD!' ? 'text-green-400' :
              'text-red-400'
            }`}>
              {judgmentText}
            </div>
          )}

          {/* タップエリア */}
          <div className="absolute bottom-0 left-0 right-0 flex h-20">
            {[0, 1, 2, 3].map(lane => (
              <button
                key={lane}
                className="flex-1 bg-white/10 hover:bg-white/20 active:bg-white/30 transition-colors border-r border-white/20 last:border-r-0 text-white/50 font-bold text-sm relative"
                onMouseDown={() => handleTap(lane)}
                onTouchStart={(e) => {
                  e.preventDefault();
                  handleTap(lane);
                }}
              >
                <div className="absolute inset-0 flex items-center justify-center">
                  {lane + 1}
                </div>
              </button>
            ))}
          </div>
        </div>

        {/* コントロール */}
        <div className="flex justify-center gap-4 mb-4">
          {gameState === 'ready' && analysisComplete && (
            <button
              onClick={startGame}
              className="flex items-center gap-2 bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors"
            >
              <Play size={20} />
              スタート
            </button>
          )}
          
          {(gameState === 'playing' || gameState === 'paused') && (
            <>
              <button
                onClick={togglePause}
                className="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition-colors"
              >
                {gameState === 'playing' ? <Pause size={20} /> : <Play size={20} />}
                {gameState === 'playing' ? 'ポーズ' : '再開'}
              </button>
              <button
                onClick={resetGame}
                className="flex items-center gap-2 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg transition-colors"
              >
                <RotateCcw size={20} />
                リセット
              </button>
            </>
          )}
          
          {gameState === 'finished' && (
            <button
              onClick={resetGame}
              className="flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg transition-colors"
            >
              <RotateCcw size={20} />
              もう一度
            </button>
          )}
        </div>

        {/* 新しいファイル選択 */}
        {audioFile && (
          <div className="text-center mb-4">
            <label className="text-sm text-gray-400 cursor-pointer hover:text-white transition-colors">
              別の楽曲を選択
              <input
                type="file"
                accept="audio/*,.mp3,.wav,.ogg,.m4a,.flac,.aac"
                onChange={handleFileUpload}
                className="hidden"
              />
            </label>
          </div>
        )}

        {/* 操作説明 */}
        <div className="text-xs text-gray-400 text-center">
          <p>音楽ファイルをアップロードして、楽曲のビートに合わせてプレイ！</p>
          <p>解析に失敗した場合は「シンプルパターン」を使用できます</p>
          <p>キーボード操作：1, 2, 3, 4 キーでもタップできます</p>
        </div>
      </div>
    </div>
  );
};

export default MusicAnalyzerRhythmGame;